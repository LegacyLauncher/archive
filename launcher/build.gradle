import groovy.json.JsonBuilder
import org.yaml.snakeyaml.Yaml

import java.security.DigestInputStream
import java.security.MessageDigest

plugins {
    id 'java'
    id "org.openjfx.javafxplugin"
    id "com.github.gmazzo.buildconfig"
}

apply from: '../gradle/java.gradle'
apply from: '../gradle/javafx.gradle'

sourceSets {
    java11 {
        compileClasspath += main.compileClasspath
        runtimeClasspath += main.runtimeClasspath
        compileClasspath += main.output
        java {
            srcDirs = files("src/main/java11")
        }
    }
}

compileJava11Java {
    options.release.set(11)
}

compileTestJava {
    options.release.set(11)
}

configurations {
    // exclude runtimeOnly stuff (like javafx) from *meta.json
    exportedClasspath {
        canBeConsumed = false
        canBeResolved = true
        extendsFrom(runtimeClasspath, java11RuntimeClasspath)
        // TODO this line removes JavaFX from debug runs
        exclude(group: 'org.openjfx')
    }
}

evaluationDependsOn(":common")

dependencies {
    compileOnly(project(":bridge")) // bootstrap-java will inject it, all others don't need and don't use it

    annotationProcessor(libs.log4j.core)

    implementation(project(":common"))
    implementation(libs.authlib)
    implementation(libs.bundles.httpcomponents)
    implementation(libs.bundles.log4j)
    implementation(libs.commons.compress)
    implementation(libs.commons.io)
    implementation(libs.flatlaf)
    implementation(libs.gson)
    implementation(libs.guava)
    implementation(libs.jackson.core)
    implementation(libs.jarscanner)
    implementation(libs.java.semver)
    implementation(libs.java.statsd.client)
    implementation(libs.jdom)
    implementation(libs.jopt.simple)
    implementation(libs.jvd)
    implementation(libs.nanohttpd)
    implementation(libs.nstweaker)
    implementation(libs.oshi)
    implementation(libs.sentry)
    implementation(libs.toml4j)
    implementation(libs.xz)

    java11CompileOnly(project(":common").sourceSets.java11.output)
    java11Implementation(libs.bundles.dbus)
    java11RuntimeOnly(project(":dbus-java-transport-junixsocket"))

    testImplementation(libs.junit.jupiter.api)
    testImplementation(libs.mockito.core)
    testRuntimeOnly(libs.junit.jupiter.engine)
    testRuntimeOnly(libs.mockito.junit.jupiter)
    testRuntimeOnly(libs.mockito.inline)
}

task buildLauncherRepo(type: Sync) {
    destinationDir = file("${rootProject.rootDir}/lib/${short_brand}")
    inputs.files(configurations.exportedClasspath)
    configurations.exportedClasspath.resolvedConfiguration.resolvedArtifacts.each { artifact ->
        def path = artifact.moduleVersion.id.with {
            "${group.replace('.', '/')}/${name}/$version"
        }
        into(path) {
            from(artifact.file)
        }
    }
}

static def generateChecksum(File file) {
    file.withInputStream {
        new DigestInputStream(it, MessageDigest.getInstance('SHA-256')).withStream {
            it.eachByte {}
            it.messageDigest.digest().encodeHex() as String
        }
    }
}

static String formatShortArtifactNotation(ResolvedArtifact artifact) {
    String name = artifact.moduleVersion.toString()
    if (artifact.classifier != null) {
        return "$name:${artifact.classifier}"
    }
    return name
}

static void writeMeta(File file, Map<String, Object> content) {
    file.parentFile.mkdirs()
    file.text = new JsonBuilder(content).toString();
}

processResources {
    inputs.files(configurations.exportedClasspath)
    inputs.property("product_version", product_version)
    inputs.property("short_brand", short_brand)
    inputs.property("full_brand", full_brand)

    doLast {
        def meta = [
                version   : product_version,
                shortBrand: short_brand,
                brand     : full_brand,
                libraries : configurations.exportedClasspath.resolvedConfiguration.resolvedArtifacts.collect { ResolvedArtifact artifact ->
                    [name: formatShortArtifactNotation(artifact), checksum: generateChecksum(artifact.file)]
                },
        ]

        // meta for old bootstrap-java
        writeMeta(new File(destinationDir, "ru/turikhay/tlauncher/meta.json"), meta + [
                mainClass: 'net.legacylauncher.LegacyLauncherBridged',
        ])

        // meta for *modern* bootstraps :)
        writeMeta(new File(destinationDir, "META-INF/launcher-meta.json"), meta + [
                bridgedEntryPoint: 'net.legacylauncher.LegacyLauncherBridged',
                entryPoint       : 'net.legacylauncher.LegacyLauncherEntrypoint',
                repositories     : (repo_hosts.collect { "https://$it" } + repo_cdn_path_prefixes).collect { "$it/repo/libraries" },
                javaVersion      : '[11,)', // recommended java version as per https://maven.apache.org/enforcer/enforcer-rules/versionRanges.html
        ])
    }
}

task generateUpdateJson {
    dependsOn(jar)

    doLast {
        def jarFileChecksum = generateChecksum(jar.outputs.files.singleFile)

        def downloadPath = "repo/update/${short_brand}/launcher/${jarFileChecksum}.jar"

        def downloadUrlList = repo_hosts.collect { host ->
            ["http", "https"].collect {scheme ->
                "${scheme}://${host}/${downloadPath}"
            }
        }.flatten().toSet().sort { a, b ->
            a.startsWith("https") ? (b.startsWith("https") ? 0 : -1) : (b.startsWith("https") ? 1 : 0)
        }

        def changelog = null
        if (System.getenv("INCLUDE_CHANGELOG") == 'true') {
            new File("$projectDir/changelog.yml").withReader('UTF-8') {reader ->
                changelog = new Yaml().load(reader)
            }
        }

        def meta = [
                version    : product_version,
                checksum   : jarFileChecksum,
                url        : downloadUrlList,
                description: changelog
        ]

        file("${buildDir}/update/${short_brand}/launcher.json").write(new JsonBuilder(meta).toString())
    }
}

task copyJarAndRename(type: Copy) {
    from jar
    into "${buildDir}/update/${short_brand}"
    rename { "launcher.jar" }
}

task generateSha256File {
    dependsOn jar
    doLast {
        file("${buildDir}/update/${short_brand}/launcher.jar.sha256").write(generateChecksum(jar.outputs.files.singleFile))
    }
}

buildConfig {
    className("BuildConfig")
    packageName("net.legacylauncher.configuration")

    useJavaOutput()

    buildConfigField('String', 'SHORT_BRAND', "\"${short_brand}\"")
    buildConfigField('String', 'FULL_BRAND', "\"${full_brand}\"")
    buildConfigField('String', 'VERSION', "\"${product_version}\"")
}

assemble {
    dependsOn(generateUpdateJson, copyJarAndRename, generateSha256File)
}

jar {
    into('META-INF/versions/11') {
        from sourceSets.java11.output
    }

    manifest.attributes(
            'Multi-Release': true
    )
}

test {
    useJUnitPlatform()
}
